ALTER SESSION SET "_ORACLE_SCRIPT" =TRUE;
--Creacion de usuario
CREATE USER tienda_mascotas1 IDENTIFIED BY tienda1234;
CREATE TABLESPACE tienda_mascotas_2
DATAFILE 'C:\APP\PORTU\PRODUCT\21C\ORADATA\XE\TIENDA_MASCOTAS_TBS.DBF' SIZE 100M;

--CREACION USUARIO
CREATE USER tienda_mascotas1 
IDENTIFIED BY tienda1234 
ALTER USER tienda_mascotas1 DEFAULT TABLESPACE TIENDA_MASCOTAS;
ALTER USER tienda_mascotas1 QUOTA UNLIMITED ON TIENDA_MASCOTAS;
ALTER USER tienda_mascotas1 QUOTA UNLIMITED ON USERS;

-- Asignar privilegios
GRANT CONNECT, RESOURCE TO tienda_mascotas1;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, 
      CREATE TRIGGER, CREATE PROCEDURE 
TO tienda_mascotas1;
GRANT ALTER ANY PROCEDURE TO tienda_mascotas1;
GRANT ALTER ANY TRIGGER TO tienda_mascotas1; 
GRANT DROP ANY VIEW TO tienda_mascotas1;
GRANT DROP ANY PROCEDURE TO tienda_mascotas1;
GRANT DROP ANY TRIGGER TO tienda_mascotas1; 

-- Creaci�n de las tablas 

-- Crear tabla ESTADO
CREATE TABLE ESTADO (
    ID_ESTADO NUMBER(10) PRIMARY KEY,
    NOMBRE    VARCHAR2(255)
);

-- Crear secuencia para la tabla ESTADO
CREATE SEQUENCE seq_estado INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_ESTADO
CREATE OR REPLACE TRIGGER trg_estado_before_insert
BEFORE INSERT ON ESTADO
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := seq_estado.NEXTVAL;
END;

-- Crear tabla PROVEEDORES
CREATE TABLE PROVEEDORES (
    ID_PROVEEDOR NUMBER(10) PRIMARY KEY,
    NOMBRE       VARCHAR2(255),
    TELEFONO     VARCHAR2(15),
    CORREO       VARCHAR2(255),
    ID_ESTADO    NUMBER(10),
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla PROVEEDORES
CREATE SEQUENCE seq_proveedores INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_PROVEEDOR
CREATE OR REPLACE TRIGGER trg_proveedores_before_insert
BEFORE INSERT ON PROVEEDORES
FOR EACH ROW
BEGIN
  :NEW.ID_PROVEEDOR := seq_proveedores.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_proveedores_set_estado
BEFORE INSERT ON PROVEEDORES
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;

-- Crear tabla ESPECIE
CREATE TABLE ESPECIE (
    ID_ESPECIE NUMBER(10) PRIMARY KEY,
    NOMBRE     VARCHAR2(255),
    ID_ESTADO  NUMBER(10),
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla ESPECIE
CREATE SEQUENCE seq_especie INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_ESPECIE
CREATE OR REPLACE TRIGGER trg_especie_before_insert
BEFORE INSERT ON ESPECIE
FOR EACH ROW
BEGIN
  :NEW.ID_ESPECIE := seq_especie.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_especie_set_estado
BEFORE INSERT ON ESPECIE
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;


-- Crear tabla USUARIOS
CREATE TABLE USUARIOS (
    ID_USUARIO  NUMBER(10) PRIMARY KEY,
    NOMBRE      VARCHAR2(255),
    APELLIDO    VARCHAR2(255),
    TELEFONO    VARCHAR2(15),
    CORREO      VARCHAR2(255),
    CONTRASENNA VARCHAR2(255),
    ID_ESTADO   NUMBER(10),
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla USUARIOS
CREATE SEQUENCE seq_usuarios INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_USUARIO
CREATE OR REPLACE TRIGGER trg_usuarios_before_insert
BEFORE INSERT ON USUARIOS
FOR EACH ROW
BEGIN
  :NEW.ID_USUARIO := seq_usuarios.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_usuarios_set_estado
BEFORE INSERT ON USUARIOS
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;

-- Crear tabla CATEGORIAS
CREATE TABLE CATEGORIAS (
    ID_CATEGORIA NUMBER(10) PRIMARY KEY,
    NOMBRE       VARCHAR2(255),
    ID_ESTADO    NUMBER(10),
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla CATEGORIAS
CREATE SEQUENCE seq_categorias INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_CATEGORIA
CREATE OR REPLACE TRIGGER trg_categorias_before_insert
BEFORE INSERT ON CATEGORIAS
FOR EACH ROW
BEGIN
  :NEW.ID_CATEGORIA := seq_categorias.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_categorias_set_estado
BEFORE INSERT ON CATEGORIAS
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;

-- Crear tabla PRODUCTOS
CREATE TABLE PRODUCTOS (
    ID_PRODUCTO  NUMBER(10) PRIMARY KEY,
    NOMBRE       VARCHAR2(255),
    DESCRIPCION  VARCHAR2(4000), 
    PRECIO       NUMBER(10, 2), 
    EXISTENCIAS  NUMBER(10),
    ID_CATEGORIA NUMBER(10),
    ID_ESPECIE   NUMBER(10),
    ID_PROVEEDOR NUMBER(10),
    ID_ESTADO    NUMBER(10),
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE,
    FOREIGN KEY (ID_CATEGORIA) REFERENCES CATEGORIAS(ID_CATEGORIA) ON DELETE CASCADE,
    FOREIGN KEY (ID_ESPECIE) REFERENCES ESPECIE(ID_ESPECIE) ON DELETE CASCADE,
    FOREIGN KEY (ID_PROVEEDOR) REFERENCES PROVEEDORES(ID_PROVEEDOR) ON DELETE CASCADE
);

-- Crear secuencia para la tabla PRODUCTOS
CREATE SEQUENCE seq_productos INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_PRODUCTO
CREATE OR REPLACE TRIGGER trg_productos_before_insert
BEFORE INSERT ON PRODUCTOS
FOR EACH ROW
BEGIN
  :NEW.ID_PRODUCTO := seq_productos.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_productos_set_estado
BEFORE INSERT ON PRODUCTOS
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;


-- Crear tabla EMPLEADOS
CREATE TABLE EMPLEADOS (
    ID_EMPLEADO NUMBER(10) PRIMARY KEY,
    ID_USUARIO  NUMBER(10),
    CARGO       VARCHAR2(255),
    ID_ESTADO   NUMBER(10),
    FOREIGN KEY (ID_USUARIO) REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla EMPLEADOS
CREATE SEQUENCE seq_empleados INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_EMPLEADO
CREATE OR REPLACE TRIGGER trg_empleados_before_insert
BEFORE INSERT ON EMPLEADOS
FOR EACH ROW
BEGIN
  :NEW.ID_EMPLEADO := seq_empleados.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_empleados_set_estado
BEFORE INSERT ON EMPLEADOS
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;

-- Crear tabla CLIENTES
CREATE TABLE CLIENTES (
    ID_CLIENTE NUMBER(10) PRIMARY KEY,
    ID_USUARIO NUMBER(10),
    ID_ESTADO  NUMBER(10),
    DIRECCION  VARCHAR2(255), 
    FOREIGN KEY (ID_USUARIO) REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla CLIENTES
CREATE SEQUENCE seq_clientes INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_CLIENTE
CREATE OR REPLACE TRIGGER trg_clientes_before_insert
BEFORE INSERT ON CLIENTES
FOR EACH ROW
BEGIN
  :NEW.ID_CLIENTE := seq_clientes.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_clientes_set_estado
BEFORE INSERT ON CLIENTES
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;

-- Crear tabla VENTAS
CREATE TABLE VENTAS (
    ID_VENTA    NUMBER(10) PRIMARY KEY,
    ID_CLIENTE  NUMBER(10),
    FECHA_VENTA DATE, 
    TOTAL       NUMBER(10, 2), 
    ID_ESTADO   NUMBER(10),
    FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE) ON DELETE CASCADE,
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla VENTAS
CREATE SEQUENCE seq_ventas INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_VENTA
CREATE OR REPLACE TRIGGER trg_ventas_before_insert
BEFORE INSERT ON VENTAS
FOR EACH ROW
BEGIN
  :NEW.ID_VENTA := seq_ventas.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_ventas_set_estado
BEFORE INSERT ON VENTAS
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;

-- Crear tabla DETALLE_VENTA
CREATE TABLE DETALLE_VENTA (
    ID_DETALLE  NUMBER(10) PRIMARY KEY,
    ID_VENTA    NUMBER(10),
    ID_PRODUCTO NUMBER(10),
    CANTIDAD    NUMBER(10),
    SUBTOTAL    NUMBER(10, 2),
    ID_ESTADO   NUMBER(10),
    FOREIGN KEY (ID_VENTA) REFERENCES VENTAS(ID_VENTA) ON DELETE CASCADE,
    FOREIGN KEY (ID_PRODUCTO) REFERENCES PRODUCTOS(ID_PRODUCTO) ON DELETE CASCADE,
    FOREIGN KEY (ID_ESTADO) REFERENCES ESTADO(ID_ESTADO) ON DELETE CASCADE
);

-- Crear secuencia para la tabla DETALLE_VENTA
CREATE SEQUENCE seq_detalle_venta
                                INCREMENT BY 1
                                START WITH 1
                                NOCYCLE
                                NOCACHE;

-- Crear trigger para la auto-incrementaci�n de ID_DETALLE
CREATE OR REPLACE TRIGGER trg_detalle_venta_before_insert
BEFORE INSERT ON DETALLE_VENTA
FOR EACH ROW
BEGIN
  :NEW.ID_DETALLE := seq_detalle_venta.NEXTVAL;
END;

CREATE OR REPLACE TRIGGER trg_detalle_venta_set_estado
BEFORE INSERT ON DETALLE_VENTA
FOR EACH ROW
BEGIN
  :NEW.ID_ESTADO := 1;
END;

--------------------------------------------------------------------------------------------------------------------------------------------------------------

-- Insersi�n de datos en las tablas
INSERT INTO ESTADO (NOMBRE) VALUES ('ACTIVO');
INSERT INTO ESTADO (NOMBRE) VALUES ('INACTIVO');

-- Insertar datos en la tabla PROVEEDORES
INSERT INTO PROVEEDORES (NOMBRE, TELEFONO, CORREO) VALUES ('Proveedores S.A.', '123456789', 'proveedores@example.com');
INSERT INTO PROVEEDORES (NOMBRE, TELEFONO, CORREO) VALUES ('Distribuidora Norte', '987654321', 'distribuidora@example.com');
INSERT INTO PROVEEDORES (NOMBRE, TELEFONO, CORREO) VALUES ('Alimentos Frescos', '555555555', 'alimentos@example.com');
INSERT INTO PROVEEDORES (NOMBRE, TELEFONO, CORREO) VALUES ('Suministros Rápidos', '111111111', 'suministros@example.com');
INSERT INTO PROVEEDORES (NOMBRE, TELEFONO, CORREO) VALUES ('Global Proveedores', '999999999', 'global@example.com');

-- Insertar datos en la tabla ESPECIE
INSERT INTO ESPECIE (NOMBRE) VALUES ('Perro');
INSERT INTO ESPECIE (NOMBRE) VALUES ('Gato');
INSERT INTO ESPECIE (NOMBRE) VALUES ('Ave');
INSERT INTO ESPECIE (NOMBRE) VALUES ('Pez');
INSERT INTO ESPECIE (NOMBRE) VALUES ('Reptil');
INSERT INTO ESPECIE (NOMBRE) VALUES ('Roedores');
INSERT INTO ESPECIE (NOMBRE) VALUES ('Granja');

-- Insertar datos en la tabla USUARIOS
INSERT INTO USUARIOS (NOMBRE, APELLIDO, TELEFONO, CORREO) VALUES ('Carlos', 'Pérez', '111222333', 'carlosp@example.com');
INSERT INTO USUARIOS (NOMBRE, APELLIDO, TELEFONO, CORREO) VALUES ('Ana', 'Mora', '444555666', 'anam@example.com');
INSERT INTO USUARIOS (NOMBRE, APELLIDO, TELEFONO, CORREO) VALUES ('Carlos', 'López', '777888999', 'carlosl@example.com');
INSERT INTO USUARIOS (NOMBRE, APELLIDO, TELEFONO, CORREO) VALUES ('María', 'Martínez', '222333444', 'mariamar@example.com');
INSERT INTO USUARIOS (NOMBRE, APELLIDO, TELEFONO, CORREO) VALUES ('Luis', 'Solano', '555666777', 'luissolano@example.com');

-- Insertar datos en la tabla CATEGORIAS
INSERT INTO CATEGORIAS (NOMBRE) VALUES ('Alimentos');
INSERT INTO CATEGORIAS (NOMBRE) VALUES ('Juguetes');
INSERT INTO CATEGORIAS (NOMBRE) VALUES ('Accesorios');
INSERT INTO CATEGORIAS (NOMBRE) VALUES ('Medicamentos');
INSERT INTO CATEGORIAS (NOMBRE) VALUES ('Higiene');

-- Insertar datos en la tabla PRODUCTOS
INSERT INTO PRODUCTOS (NOMBRE, DESCRIPCION, PRECIO, EXISTENCIAS, ID_CATEGORIA, ID_ESPECIE, ID_PROVEEDOR) 
VALUES ('Comida para perro', 'Alimento balanceado para perros adultos', 25.99, 100, 1, 1, 1);
INSERT INTO PRODUCTOS (NOMBRE, DESCRIPCION, PRECIO, EXISTENCIAS, ID_CATEGORIA, ID_ESPECIE, ID_PROVEEDOR) 
VALUES ('Comida para gato', 'Alimento balanceado para gatos adultos', 20.99, 80, 1, 2, 2);
INSERT INTO PRODUCTOS (NOMBRE, DESCRIPCION, PRECIO, EXISTENCIAS, ID_CATEGORIA, ID_ESPECIE, ID_PROVEEDOR) 
VALUES ('Juguete para ave', 'Juguete de colores para aves', 5.99, 150, 2, 3, 3);
INSERT INTO PRODUCTOS (NOMBRE, DESCRIPCION, PRECIO, EXISTENCIAS, ID_CATEGORIA, ID_ESPECIE, ID_PROVEEDOR) 
VALUES ('Acuario pequeño', 'Acuario de 10 litros para peces pequeños', 35.99, 30, 3, 4, 4);
INSERT INTO PRODUCTOS (NOMBRE, DESCRIPCION, PRECIO, EXISTENCIAS, ID_CATEGORIA, ID_ESPECIE, ID_PROVEEDOR) 
VALUES ('Vitamina para reptiles', 'Suplemento vitamínico para reptiles', 15.99, 50, 4, 5, 5);

-- Insertar datos en la tabla EMPLEADOS
INSERT INTO EMPLEADOS (ID_USUARIO, CARGO) VALUES (1, 'Gerente');
INSERT INTO EMPLEADOS (ID_USUARIO, CARGO) VALUES (2, 'Vendedor');

-- Insertar datos en la tabla CLIENTES
INSERT INTO CLIENTES (ID_USUARIO, DIRECCION) VALUES (3, '500mts sur del paseo metropoli');
INSERT INTO CLIENTES (ID_USUARIO, DIRECCION) VALUES (4, 'Un kilometro al este de Gasolinera Trova');
INSERT INTO CLIENTES (ID_USUARIO, DIRECCION) VALUES (5, 'Frente al parque central de tejar');

-- Insertar datos en la tabla VENTAS
INSERT INTO VENTAS (ID_CLIENTE, FECHA_VENTA, TOTAL) 
VALUES (1, TO_DATE('2024-10-01', 'YYYY-MM-DD'), 100.50);
INSERT INTO VENTAS (ID_CLIENTE, FECHA_VENTA, TOTAL) 
VALUES (2, TO_DATE('2024-10-02', 'YYYY-MM-DD'), 75.25);
INSERT INTO VENTAS (ID_CLIENTE, FECHA_VENTA, TOTAL) 
VALUES (3, TO_DATE('2024-10-03', 'YYYY-MM-DD'), 200.00);

-- Insertar datos en la tabla DETALLE_VENTA
INSERT INTO DETALLE_VENTA (ID_VENTA, ID_PRODUCTO, CANTIDAD, SUBTOTAL) 
VALUES (1, 1, 2, 51.98);
INSERT INTO DETALLE_VENTA (ID_VENTA, ID_PRODUCTO, CANTIDAD, SUBTOTAL) 
VALUES (1, 2, 1, 20.99);
INSERT INTO DETALLE_VENTA (ID_VENTA, ID_PRODUCTO, CANTIDAD, SUBTOTAL) 
VALUES (2, 3, 3, 17.97);
INSERT INTO DETALLE_VENTA (ID_VENTA, ID_PRODUCTO, CANTIDAD, SUBTOTAL) 
VALUES (3, 4, 1, 35.99);

--Creaci�n de los procedimientos almacenados, paquetes y cursores

-- Paquete para proveedores

--Especificaci�n del paquete 
CREATE OR REPLACE PACKAGE pkg_proveedores AS
    PROCEDURE SP_INSERTAR_PROVEEDOR(
        P_NOMBRE   IN VARCHAR2,
        P_TELEFONO IN VARCHAR2,
        P_CORREO   IN VARCHAR2
    );

    PROCEDURE SP_ACTUALIZAR_PROVEEDOR(
        P_ID_PROVEEDOR IN NUMBER,
        P_NOMBRE       IN VARCHAR2,
        P_TELEFONO     IN VARCHAR2,
        P_CORREO       IN VARCHAR2
    );

    PROCEDURE SP_ELIMINAR_PROVEEDOR(
        P_ID_PROVEEDOR IN NUMBER
    );

    PROCEDURE SP_OBTENER_PROVEEDORES_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );

    PROCEDURE SP_OBTENER_PROVEEDOR_CS(
        P_ID_PROVEEDOR IN NUMBER,
        P_CURSOR       OUT SYS_REFCURSOR
    );
END pkg_proveedores;
/

-- Cuerpo del paquete
CREATE OR REPLACE PACKAGE BODY pkg_proveedores AS

    PROCEDURE SP_INSERTAR_PROVEEDOR(
        P_NOMBRE   IN VARCHAR2,
        P_TELEFONO IN VARCHAR2,
        P_CORREO   IN VARCHAR2
    ) AS 
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM PROVEEDORES
        WHERE CORREO = P_CORREO;

        IF V_COUNT > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Ya existe un proveedor con el mismo correo.');
        END IF;

        INSERT INTO PROVEEDORES (NOMBRE, TELEFONO, CORREO)
        VALUES (P_NOMBRE, P_TELEFONO, P_CORREO);

        COMMIT;
    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados. Verifique los tipos de datos.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ACTUALIZAR_PROVEEDOR(
        P_ID_PROVEEDOR IN NUMBER,
        P_NOMBRE       IN VARCHAR2,
        P_TELEFONO     IN VARCHAR2,
        P_CORREO       IN VARCHAR2
    ) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM PROVEEDORES
        WHERE ID_PROVEEDOR = P_ID_PROVEEDOR;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El proveedor con el ID proporcionado no existe.');
        END IF;

        UPDATE PROVEEDORES
        SET NOMBRE   = P_NOMBRE,
            TELEFONO = P_TELEFONO, 
            CORREO   = P_CORREO
        WHERE ID_PROVEEDOR = P_ID_PROVEEDOR;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ELIMINAR_PROVEEDOR(
        P_ID_PROVEEDOR IN NUMBER
    ) AS
    BEGIN
        UPDATE PROVEEDORES
        SET ID_ESTADO = CASE
                            WHEN ID_ESTADO = 1 THEN 2
                            WHEN ID_ESTADO = 2 THEN 1
                            ELSE ID_ESTADO
                        END
        WHERE ID_PROVEEDOR = P_ID_PROVEEDOR;

        COMMIT;
    END;

    PROCEDURE SP_OBTENER_PROVEEDORES_CS(
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT P.ID_PROVEEDOR, P.NOMBRE, P.TELEFONO, P.CORREO, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM PROVEEDORES P
        JOIN ESTADO E ON P.ID_ESTADO = E.ID_ESTADO;
    END;

    PROCEDURE SP_OBTENER_PROVEEDOR_CS(
        P_ID_PROVEEDOR IN NUMBER,
        P_CURSOR       OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT P.ID_PROVEEDOR, P.NOMBRE, P.TELEFONO, P.CORREO, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM PROVEEDORES P
        JOIN ESTADO E ON P.ID_ESTADO = E.ID_ESTADO
        WHERE P.ID_PROVEEDOR = P_ID_PROVEEDOR;
    END;

END pkg_proveedores;
/


-- PAQUETE ESPECIES

-- Especificaci�n del paquete
CREATE OR REPLACE PACKAGE pkg_especie AS
    PROCEDURE SP_INSERTAR_ESPECIE(P_NOMBRE IN VARCHAR2);
    PROCEDURE SP_ACTUALIZAR_ESPECIE(P_ID_ESPECIE IN NUMBER, P_NOMBRE IN VARCHAR2);
    PROCEDURE SP_ELIMINAR_ESPECIE(P_ID_ESPECIE IN NUMBER);
    PROCEDURE SP_OBTENER_ESPECIES_CS(P_CURSOR OUT SYS_REFCURSOR);
    PROCEDURE SP_OBTENER_ESPECIE_CS(P_ID_ESPECIE IN NUMBER, P_CURSOR OUT SYS_REFCURSOR);
END pkg_especie;
/

-- Cuerpo del paquete
CREATE OR REPLACE PACKAGE BODY pkg_especie AS

    PROCEDURE SP_INSERTAR_ESPECIE(P_NOMBRE IN VARCHAR2) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM ESPECIE
        WHERE UPPER(NOMBRE) = UPPER(P_NOMBRE);

        IF V_COUNT > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Ya existe una especie con ese nombre.');
        END IF;

        INSERT INTO ESPECIE (NOMBRE)
        VALUES (P_NOMBRE);

        COMMIT;
    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ACTUALIZAR_ESPECIE(P_ID_ESPECIE IN NUMBER, P_NOMBRE IN VARCHAR2) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM ESPECIE
        WHERE ID_ESPECIE = P_ID_ESPECIE;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'La especie con ese ID no existe.');
        END IF;

        UPDATE ESPECIE
        SET NOMBRE = P_NOMBRE
        WHERE ID_ESPECIE = P_ID_ESPECIE;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ELIMINAR_ESPECIE(P_ID_ESPECIE IN NUMBER) AS
    BEGIN
        UPDATE ESPECIE
        SET ID_ESTADO = CASE
                            WHEN ID_ESTADO = 1 THEN 2
                            WHEN ID_ESTADO = 2 THEN 1
                            ELSE ID_ESTADO
                        END
        WHERE ID_ESPECIE = P_ID_ESPECIE;

        COMMIT;
    END;

    PROCEDURE SP_OBTENER_ESPECIES_CS(P_CURSOR OUT SYS_REFCURSOR) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT E.ID_ESPECIE, E.NOMBRE, S.ID_ESTADO, S.NOMBRE AS ESTADO
        FROM ESPECIE E
        JOIN ESTADO S ON E.ID_ESTADO = S.ID_ESTADO;
    END;

    PROCEDURE SP_OBTENER_ESPECIE_CS(P_ID_ESPECIE IN NUMBER, P_CURSOR OUT SYS_REFCURSOR) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT E.ID_ESPECIE, E.NOMBRE, S.ID_ESTADO, S.NOMBRE AS ESTADO
        FROM ESPECIE E
        JOIN ESTADO S ON E.ID_ESTADO = S.ID_ESTADO
        WHERE ID_ESPECIE = P_ID_ESPECIE;
    END;

END pkg_especie;
/

-- PAQUETE PARA CATEGORIA

--Especificaci�n del paquete 
CREATE OR REPLACE PACKAGE pkg_categorias AS
    PROCEDURE SP_INSERTAR_CATEGORIA(P_NOMBRE IN VARCHAR2);
    PROCEDURE SP_ACTUALIZAR_CATEGORIA(P_ID_CATEGORIA IN NUMBER, P_NOMBRE IN VARCHAR2);
    PROCEDURE SP_ELIMINAR_CATEGORIA(P_ID_CATEGORIA IN NUMBER);
    PROCEDURE SP_OBTENER_CATEGORIAS_CS(P_CURSOR OUT SYS_REFCURSOR);
    PROCEDURE SP_OBTENER_CATEGORIA_CS(P_ID_CATEGORIA IN NUMBER, P_CURSOR OUT SYS_REFCURSOR);
END pkg_categorias;
/

-- Cuerpo del paquete
CREATE OR REPLACE PACKAGE BODY pkg_categorias AS

    PROCEDURE SP_INSERTAR_CATEGORIA(P_NOMBRE IN VARCHAR2) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM CATEGORIAS
        WHERE UPPER(NOMBRE) = UPPER(P_NOMBRE);

        IF V_COUNT > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Ya existe una categor�a con ese nombre.');
        END IF;

        INSERT INTO CATEGORIAS (NOMBRE)
        VALUES (P_NOMBRE);

        COMMIT;
    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ACTUALIZAR_CATEGORIA(P_ID_CATEGORIA IN NUMBER, P_NOMBRE IN VARCHAR2) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM CATEGORIAS
        WHERE ID_CATEGORIA = P_ID_CATEGORIA;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'La categor�a con ese ID no existe.');
        END IF;

        UPDATE CATEGORIAS
        SET NOMBRE = P_NOMBRE
        WHERE ID_CATEGORIA = P_ID_CATEGORIA;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ELIMINAR_CATEGORIA(P_ID_CATEGORIA IN NUMBER) AS
    BEGIN
        UPDATE CATEGORIAS
        SET ID_ESTADO = CASE
                            WHEN ID_ESTADO = 1 THEN 2
                            WHEN ID_ESTADO = 2 THEN 1
                            ELSE ID_ESTADO
                        END
        WHERE ID_CATEGORIA = P_ID_CATEGORIA;

        COMMIT;
    END;

    PROCEDURE SP_OBTENER_CATEGORIAS_CS(P_CURSOR OUT SYS_REFCURSOR) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT C.ID_CATEGORIA, C.NOMBRE, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM CATEGORIAS C
        JOIN ESTADO E ON C.ID_ESTADO = E.ID_ESTADO;
    END;

    PROCEDURE SP_OBTENER_CATEGORIA_CS(P_ID_CATEGORIA IN NUMBER, P_CURSOR OUT SYS_REFCURSOR) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT C.ID_CATEGORIA, C.NOMBRE, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM CATEGORIAS C
        JOIN ESTADO E ON C.ID_ESTADO = E.ID_ESTADO
        WHERE C.ID_CATEGORIA = P_ID_CATEGORIA;
    END;

END pkg_categorias;
/
--Paquete para ventas

--Especificaci�n del paquete venta
CREATE OR REPLACE PACKAGE PKG_VENTA AS
    PROCEDURE SP_INSERTAR_VENTA(
        P_ID_CLIENTE IN NUMBER,
        P_FECHA_VENTA IN VARCHAR2,
        P_TOTAL IN NUMBER
    );
    PROCEDURE SP_ACTUALIZAR_VENTA(
        P_ID_VENTA IN NUMBER,
        P_ID_CLIENTE IN NUMBER,
        P_FECHA_VENTA IN VARCHAR2,
        P_TOTAL IN NUMBER
    );
    PROCEDURE SP_ELIMINAR_VENTA(
        P_ID_VENTA IN NUMBER
    );
    
-- CURSORES
    PROCEDURE SP_OBTENER_CLIENTES_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );
    PROCEDURE SP_OBTENER_VENTAS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );
    PROCEDURE SP_OBTENER_VENTA_CS(
        P_ID_VENTA IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    );
END PKG_VENTA;
/

--Cuerpo del paquete de venta
CREATE OR REPLACE PACKAGE BODY PKG_VENTA AS
--Insertar venta
    PROCEDURE SP_INSERTAR_VENTA(
        P_ID_CLIENTE IN NUMBER,
        P_FECHA_VENTA IN VARCHAR2,
        P_TOTAL IN NUMBER
    ) AS 
    BEGIN
        INSERT INTO VENTAS (ID_CLIENTE, FECHA_VENTA, TOTAL)
        VALUES (P_ID_CLIENTE, TO_DATE(P_FECHA_VENTA, 'YYYY-MM-DD'), P_TOTAL);

        COMMIT;

    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados. Verifique los tipos de datos.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;
-- 2. Actualizar VENTA
    PROCEDURE SP_ACTUALIZAR_VENTA(
        P_ID_VENTA IN NUMBER,
        P_ID_CLIENTE IN NUMBER,
        P_FECHA_VENTA IN VARCHAR2,
        P_TOTAL IN NUMBER
    ) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM VENTAS
        WHERE ID_VENTA = P_ID_VENTA;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'La venta con el ID proporcionado no existe.');
        END IF;

        UPDATE VENTAS
        SET ID_CLIENTE = P_ID_CLIENTE,
            FECHA_VENTA = TO_DATE(P_FECHA_VENTA, 'YYYY-MM-DD'),
            TOTAL = P_TOTAL
        WHERE ID_VENTA = P_ID_VENTA;

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;
-- 3. Eliminar VENTA
    PROCEDURE SP_ELIMINAR_VENTA(
        P_ID_VENTA IN NUMBER
    ) AS
    BEGIN
        UPDATE VENTAS
        SET ID_ESTADO = CASE
                        WHEN ID_ESTADO = 1 THEN 2
                        WHEN ID_ESTADO = 2 THEN 1
                        ELSE ID_ESTADO
                    END
        WHERE ID_VENTA = P_ID_VENTA;

        COMMIT;
    END;
-- CURSORES
    PROCEDURE SP_OBTENER_CLIENTES_CS(
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT C.ID_CLIENTE, C.ID_USUARIO, U.NOMBRE AS CLIENTE, E.ID_ESTADO, E.NOMBRE AS ESTADO, C.DIRECCION
        FROM CLIENTES C
        JOIN ESTADO E ON C.ID_ESTADO = E.ID_ESTADO
        JOIN USUARIOS U ON C.ID_USUARIO = U.ID_USUARIO;
    END;

    PROCEDURE SP_OBTENER_VENTAS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT V.ID_VENTA, V.ID_CLIENTE, U.NOMBRE AS CLIENTE, V.FECHA_VENTA, V.TOTAL, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM VENTAS V
        JOIN ESTADO E ON V.ID_ESTADO = E.ID_ESTADO
        JOIN CLIENTES C ON V.ID_CLIENTE = C.ID_CLIENTE
        JOIN USUARIOS U ON C.ID_USUARIO = U.ID_USUARIO;
    END;

    PROCEDURE SP_OBTENER_VENTA_CS(
        P_ID_VENTA IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT V.ID_VENTA, V.ID_CLIENTE, U.NOMBRE AS CLIENTE, V.FECHA_VENTA, V.TOTAL, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM VENTAS V
        JOIN ESTADO E ON V.ID_ESTADO = E.ID_ESTADO
        JOIN CLIENTES C ON V.ID_CLIENTE = C.ID_CLIENTE
        JOIN USUARIOS U ON C.ID_USUARIO = U.ID_USUARIO
        WHERE ID_VENTA = P_ID_VENTA;
    END;

END PKG_VENTA;
/

--Paquete para Detalle Venta

--Especificaci�n del paquete detalle venta
CREATE OR REPLACE PACKAGE PKG_DETALLE_VENTA AS
--Insertar DETALLE VENTA
    PROCEDURE SP_INSERTAR_DETALLE_VENTA(
        P_ID_VENTA    IN NUMBER,
        P_ID_PRODUCTO IN NUMBER,
        P_CANTIDAD    IN NUMBER,
        P_SUBTOTAL    IN NUMBER
    );

-- 2. Actualizar DETALLE VENTA
    PROCEDURE SP_ACTUALIZAR_DETALLE_VENTA(
        P_ID_DETALLE  IN NUMBER,
        P_ID_VENTA    IN NUMBER,
        P_ID_PRODUCTO IN NUMBER,
        P_CANTIDAD    IN NUMBER,
        P_SUBTOTAL    IN NUMBER
    );
    
-- 3. Eliminar VENTA
    PROCEDURE SP_ELIMINAR_DETALLE_VENTA(
        P_ID_DETALLE IN NUMBER
    );

-- CURSORES
    PROCEDURE SP_OBTENER_DETALLE_VENTAS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );

    PROCEDURE SP_OBTENER_DETALLE_VENTA_CS(
        P_ID_DETALLE IN NUMBER,
        P_CURSOR     OUT SYS_REFCURSOR
    );

END PKG_DETALLE_VENTA;
/

--Cuerpo del paquete de detalle venta
CREATE OR REPLACE PACKAGE BODY PKG_DETALLE_VENTA AS
--Insertar DETALLE VENTA
    PROCEDURE SP_INSERTAR_DETALLE_VENTA(
        P_ID_VENTA    IN NUMBER,
        P_ID_PRODUCTO IN NUMBER,
        P_CANTIDAD    IN NUMBER,
        P_SUBTOTAL    IN NUMBER
    ) AS 
    BEGIN
        INSERT INTO DETALLE_VENTA (ID_VENTA, ID_PRODUCTO, CANTIDAD, SUBTOTAL)
        VALUES (P_ID_VENTA, P_ID_PRODUCTO, P_CANTIDAD, P_SUBTOTAL);

        COMMIT;
    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados. Verifique los tipos de datos.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;
    
-- 2. Actualizar DETALLE VENTA
    PROCEDURE SP_ACTUALIZAR_DETALLE_VENTA(
        P_ID_DETALLE  IN NUMBER,
        P_ID_VENTA    IN NUMBER,
        P_ID_PRODUCTO IN NUMBER,
        P_CANTIDAD    IN NUMBER,
        P_SUBTOTAL    IN NUMBER
    ) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM DETALLE_VENTA
        WHERE ID_DETALLE = P_ID_DETALLE;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El detalle de venta consultado no existe');
        END IF;

        UPDATE DETALLE_VENTA
        SET ID_VENTA = P_ID_VENTA,
            ID_PRODUCTO = P_ID_PRODUCTO,
            CANTIDAD = P_CANTIDAD,
            SUBTOTAL = P_SUBTOTAL
        WHERE ID_DETALLE = P_ID_DETALLE;

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;

-- 3. Eliminar detalle venta
    PROCEDURE SP_ELIMINAR_DETALLE_VENTA(
        P_ID_DETALLE IN NUMBER
    ) AS
    BEGIN
        UPDATE DETALLE_VENTA
        SET ID_ESTADO = CASE
                            WHEN ID_ESTADO = 1 THEN 2
                            WHEN ID_ESTADO = 2 THEN 1
                            ELSE ID_ESTADO
                        END
        WHERE ID_DETALLE = P_ID_DETALLE;

        COMMIT;
    END;
    
-- CURSORES
    PROCEDURE SP_OBTENER_DETALLE_VENTAS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT D.ID_DETALLE,
               D.ID_VENTA,
               U.NOMBRE || ' ' || U.APELLIDO AS CLIENTE,
               D.ID_PRODUCTO,
               P.NOMBRE AS PRODUCTO,
               D.CANTIDAD,
               D.SUBTOTAL,
               E.ID_ESTADO,
               E.NOMBRE AS ESTADO
        FROM DETALLE_VENTA D
        JOIN ESTADO E ON D.ID_ESTADO = E.ID_ESTADO
        JOIN PRODUCTOS P ON D.ID_PRODUCTO = P.ID_PRODUCTO
        JOIN VENTAS V ON D.ID_VENTA = V.ID_VENTA
        JOIN CLIENTES C ON V.ID_CLIENTE = C.ID_CLIENTE
        JOIN USUARIOS U ON C.ID_USUARIO = U.ID_USUARIO;
    END;

    PROCEDURE SP_OBTENER_DETALLE_VENTA_CS(
        P_ID_DETALLE IN NUMBER,
        P_CURSOR     OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT D.ID_DETALLE,
               D.ID_VENTA,
               U.NOMBRE || ' ' || U.APELLIDO AS CLIENTE,
               D.ID_PRODUCTO,
               P.NOMBRE AS PRODUCTO,
               D.CANTIDAD,
               D.SUBTOTAL,
               E.ID_ESTADO,
               E.NOMBRE AS ESTADO
        FROM DETALLE_VENTA D
        JOIN ESTADO E ON D.ID_ESTADO = E.ID_ESTADO
        JOIN PRODUCTOS P ON D.ID_PRODUCTO = P.ID_PRODUCTO
        JOIN VENTAS V ON D.ID_VENTA = V.ID_VENTA
        JOIN CLIENTES C ON V.ID_CLIENTE = C.ID_CLIENTE
        JOIN USUARIOS U ON C.ID_USUARIO = U.ID_USUARIO
        WHERE D.ID_DETALLE = P_ID_DETALLE;
    END;

END PKG_DETALLE_VENTA;
/

--Paquete para Producto

--Especificaci�n del paquete Producto
CREATE OR REPLACE PACKAGE PKG_PRODUCTOS AS
-- 1. Insertar Producto
    PROCEDURE SP_INSERTAR_PRODUCTO(
        P_NOMBRE IN VARCHAR2,
        P_DESCRIPCION IN VARCHAR2,
        P_PRECIO IN NUMBER,
        P_EXISTENCIAS IN NUMBER,
        P_CATEGORIA IN NUMBER,
        P_ESPECIE IN NUMBER,
        P_PROVEEDOR IN NUMBER
    );
    
-- 2. Actualizar Producto
    PROCEDURE SP_ACTUALIZAR_PRODUCTO(
        P_ID_PRODUCTO IN NUMBER,
        P_NOMBRE IN VARCHAR2,
        P_DESCRIPCION IN VARCHAR2,
        P_PRECIO IN NUMBER,
        P_EXISTENCIAS IN NUMBER,
        P_CATEGORIA IN NUMBER,
        P_ESPECIE IN NUMBER,
        P_PROVEEDOR IN NUMBER
    );

-- 3. Eliminar Producto
    PROCEDURE SP_ELIMINAR_PRODUCTO(
        P_ID_PRODUCTO IN NUMBER
    );

    -- Cursores
    PROCEDURE SP_OBTENER_PRODUCTOS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );
    
    PROCEDURE SP_OBTENER_PRODUCTO_CS(
        P_ID_PRODUCTO IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    );
END PKG_PRODUCTOS;
/

--Cuerpo del paquete de producto
CREATE OR REPLACE PACKAGE BODY PKG_PRODUCTOS AS
-- 1. Insertar Producto
    PROCEDURE SP_INSERTAR_PRODUCTO(
        P_NOMBRE IN VARCHAR2,
        P_DESCRIPCION IN VARCHAR2,
        P_PRECIO IN NUMBER,
        P_EXISTENCIAS IN NUMBER,
        P_CATEGORIA IN NUMBER,
        P_ESPECIE IN NUMBER,
        P_PROVEEDOR IN NUMBER
    )
    AS 
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM PRODUCTOS
        WHERE LOWER(NOMBRE) = LOWER(P_NOMBRE);

        IF V_COUNT > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Ya existe un producto con el mismo nombre.');
        END IF;

        INSERT INTO PRODUCTOS (NOMBRE, DESCRIPCION, PRECIO, EXISTENCIAS, ID_CATEGORIA, ID_ESPECIE, ID_PROVEEDOR)
        VALUES (P_NOMBRE, P_DESCRIPCION, P_PRECIO, P_EXISTENCIAS, P_CATEGORIA, P_ESPECIE, P_PROVEEDOR);

        COMMIT;

    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados. Verifique los tipos de datos.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;
    
-- 2. Actualizar Producto
    PROCEDURE SP_ACTUALIZAR_PRODUCTO(
        P_ID_PRODUCTO IN NUMBER,
        P_NOMBRE IN VARCHAR2,
        P_DESCRIPCION IN VARCHAR2,
        P_PRECIO IN NUMBER,
        P_EXISTENCIAS IN NUMBER,
        P_CATEGORIA IN NUMBER,
        P_ESPECIE IN NUMBER,
        P_PROVEEDOR IN NUMBER
    )
    AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM PRODUCTOS
        WHERE ID_PRODUCTO = P_ID_PRODUCTO;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El producto con el ID proporcionado no existe.');
        END IF;

        UPDATE PRODUCTOS
        SET NOMBRE = P_NOMBRE,
            DESCRIPCION = P_DESCRIPCION,
            PRECIO = P_PRECIO,
            EXISTENCIAS = P_EXISTENCIAS,
            ID_CATEGORIA = P_CATEGORIA,
            ID_ESPECIE = P_ESPECIE,
            ID_PROVEEDOR = P_PROVEEDOR
        WHERE ID_PRODUCTO = P_ID_PRODUCTO;

        COMMIT;
    END;

-- 3. Eliminar Producto
    PROCEDURE SP_ELIMINAR_PRODUCTO(
        P_ID_PRODUCTO IN NUMBER
    )
    AS
    BEGIN
        UPDATE PRODUCTOS
        SET ID_ESTADO = CASE
                        WHEN ID_ESTADO = 1 THEN 2
                        WHEN ID_ESTADO = 2 THEN 1
                        ELSE ID_ESTADO
                    END
        WHERE ID_PRODUCTO = P_ID_PRODUCTO;

        COMMIT;
    END;
    
-- CURSORES
    PROCEDURE SP_OBTENER_PRODUCTOS_CS(P_CURSOR OUT SYS_REFCURSOR) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT P.ID_PRODUCTO, P.NOMBRE, P.DESCRIPCION, P.PRECIO, P.EXISTENCIAS,
               C.ID_CATEGORIA, C.NOMBRE AS CATEGORIA,
               PR.ID_PROVEEDOR, PR.NOMBRE AS PROVEEDOR,
               ES.ID_ESTADO, ES.NOMBRE AS ESTADO,
               E.ID_ESPECIE, E.NOMBRE AS ESPECIE
        FROM PRODUCTOS P
        JOIN CATEGORIAS C ON P.ID_CATEGORIA = C.ID_CATEGORIA
        JOIN ESPECIE E ON P.ID_ESPECIE = E.ID_ESPECIE
        JOIN PROVEEDORES PR ON P.ID_PROVEEDOR = PR.ID_PROVEEDOR
        JOIN ESTADO ES ON P.ID_ESTADO = ES.ID_ESTADO;
    END;

    PROCEDURE SP_OBTENER_PRODUCTO_CS(P_ID_PRODUCTO IN NUMBER, P_CURSOR OUT SYS_REFCURSOR) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT P.ID_PRODUCTO, P.NOMBRE, P.DESCRIPCION, P.PRECIO, P.EXISTENCIAS,
               C.ID_CATEGORIA, C.NOMBRE AS CATEGORIA,
               PR.ID_PROVEEDOR, PR.NOMBRE AS PROVEEDOR,
               ES.ID_ESTADO, ES.NOMBRE AS ESTADO,
               E.ID_ESPECIE, E.NOMBRE AS ESPECIE
        FROM PRODUCTOS P
        JOIN CATEGORIAS C ON P.ID_CATEGORIA = C.ID_CATEGORIA
        JOIN ESPECIE E ON P.ID_ESPECIE = E.ID_ESPECIE
        JOIN PROVEEDORES PR ON P.ID_PROVEEDOR = PR.ID_PROVEEDOR
        JOIN ESTADO ES ON P.ID_ESTADO = ES.ID_ESTADO
        WHERE P.ID_PRODUCTO = P_ID_PRODUCTO;
    END;

END PKG_PRODUCTOS;

--Paquete para USUARIOS

--Especificacion del paquete USUARIOS
CREATE OR REPLACE PACKAGE PKG_USUARIOS AS
    PROCEDURE SP_INSERTAR_USUARIO(
        P_NOMBRE IN VARCHAR2,
        P_APELLIDO IN VARCHAR2,
        P_TELEFONO IN VARCHAR2,
        P_CORREO IN VARCHAR2,
        P_CONTRASENNA IN VARCHAR2
    );
    PROCEDURE SP_ACTUALIZAR_USUARIO(
        P_ID_USUARIO IN NUMBER,
        P_NOMBRE IN VARCHAR2,
        P_APELLIDO IN VARCHAR2,
        P_TELEFONO IN VARCHAR2,
        P_CORREO IN VARCHAR2
    );
    PROCEDURE SP_ELIMINAR_USUARIO(
        P_ID_USUARIO IN NUMBER
    );
    PROCEDURE SP_OBTENER_USUARIOS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );
    PROCEDURE SP_OBTENER_USUARIO_CS(
        P_ID_USUARIO IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    );
END PKG_USUARIOS;
/

--Cuerpo del paquete de Usuarios
CREATE OR REPLACE PACKAGE BODY PKG_USUARIOS AS
    --PROCEDIMIENTO INSERTAR USUARIO
    PROCEDURE SP_INSERTAR_USUARIO(
        P_NOMBRE IN VARCHAR2,
        P_APELLIDO IN VARCHAR2,
        P_TELEFONO IN VARCHAR2,
        P_CORREO IN VARCHAR2,
        P_CONTRASENNA IN VARCHAR2
    ) AS 
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM USUARIOS
        WHERE CORREO = P_CORREO;

        IF V_COUNT > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Ya existe un usuario con el mismo correo.');
        END IF;

        INSERT INTO USUARIOS (NOMBRE, APELLIDO, TELEFONO, CORREO, CONTRASENNA)
        VALUES (P_NOMBRE, P_APELLIDO, P_TELEFONO, P_CORREO, P_CONTRASENNA);

        COMMIT;

    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados. Verifique los tipos de datos.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Se ha producido un error inesperado: ' || SQLERRM);
    END SP_INSERTAR_USUARIO;

    --PROCEDIMIENTO ACTUALIZAR USUARIO
    PROCEDURE SP_ACTUALIZAR_USUARIO(
        P_ID_USUARIO IN NUMBER,
        P_NOMBRE IN VARCHAR2,
        P_APELLIDO IN VARCHAR2,
        P_TELEFONO IN VARCHAR2,
        P_CORREO IN VARCHAR2
    ) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*)
        INTO V_COUNT
        FROM USUARIOS
        WHERE ID_USUARIO = P_ID_USUARIO;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El usuario con el ID proporcionado no existe.');
        END IF;

        UPDATE USUARIOS
        SET NOMBRE = P_NOMBRE,
            APELLIDO = P_APELLIDO,
            TELEFONO = P_TELEFONO, 
            CORREO = P_CORREO
        WHERE ID_USUARIO = P_ID_USUARIO;

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Se ha producido un error inesperado: ' || SQLERRM);
    END SP_ACTUALIZAR_USUARIO;

    --PROCEDIMIENTO ELIMINAR USUARIO
    PROCEDURE SP_ELIMINAR_USUARIO(
        P_ID_USUARIO IN NUMBER
    ) AS
    BEGIN
        UPDATE USUARIOS
        SET ID_ESTADO = CASE
                        WHEN ID_ESTADO = 1 THEN 2
                        WHEN ID_ESTADO = 2 THEN 1
                        ELSE ID_ESTADO
                    END
        WHERE ID_USUARIO = P_ID_USUARIO;

        COMMIT;
    END SP_ELIMINAR_USUARIO;

    -- CURSOR PARA OBTENER USUARIOS
    PROCEDURE SP_OBTENER_USUARIOS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT U.ID_USUARIO, U.NOMBRE, U.APELLIDO, U.TELEFONO, U.CORREO, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM USUARIOS U
        JOIN ESTADO E ON U.ID_ESTADO = E.ID_ESTADO;
    END SP_OBTENER_USUARIOS_CS;

    -- CURSOR PARA OBTENER USUARIO
    PROCEDURE SP_OBTENER_USUARIO_CS(
        P_ID_USUARIO IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT U.ID_USUARIO, U.NOMBRE, U.APELLIDO, U.TELEFONO, U.CORREO, E.ID_ESTADO, E.NOMBRE AS ESTADO
        FROM USUARIOS U
        JOIN ESTADO E ON U.ID_ESTADO = E.ID_ESTADO
        WHERE ID_USUARIO = P_ID_USUARIO;
    END SP_OBTENER_USUARIO_CS;

END PKG_USUARIOS;
/

--Paquete para CLIENTES

--Especificacion del paquete CLIENTES
CREATE OR REPLACE PACKAGE PKG_CLIENTES AS

    PROCEDURE SP_INSERTAR_CLIENTES(
        P_ID_USUARIO IN NUMBER,
        P_DIRECCION IN VARCHAR2
    );

    PROCEDURE SP_ACTUALIZAR_CLIENTES(
        P_ID_CLIENTE IN NUMBER,
        P_ID_USUARIO IN NUMBER,
        P_DIRECCION IN VARCHAR2
    );

    PROCEDURE SP_ELIMINAR_CLIENTE(
        P_ID_CLIENTE IN NUMBER
    );

    PROCEDURE SP_OBTENER_CLIENTES_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );

    PROCEDURE SP_OBTENER_CLIENTE_CS(
        P_ID_CLIENTE IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    );

END PKG_CLIENTES;
/
CREATE OR REPLACE PACKAGE BODY PKG_CLIENTES AS

    PROCEDURE SP_INSERTAR_CLIENTES(
        P_ID_USUARIO IN NUMBER,
        P_DIRECCION IN VARCHAR2
    ) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM CLIENTES
        WHERE ID_USUARIO = P_ID_USUARIO;

        IF V_COUNT > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Ya existe un cliente con el mismo id.');
        END IF;

        INSERT INTO CLIENTES (ID_USUARIO, DIRECCION)
        VALUES (P_ID_USUARIO, P_DIRECCION);

        COMMIT;

    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados. Verifique los tipos de datos.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ACTUALIZAR_CLIENTES(
        P_ID_CLIENTE IN NUMBER,
        P_ID_USUARIO IN NUMBER,
        P_DIRECCION IN VARCHAR2
    ) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM CLIENTES
        WHERE ID_CLIENTE = P_ID_CLIENTE;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El cliente con el ID proporcionado no existe.');
        END IF;

        UPDATE CLIENTES
        SET ID_USUARIO = P_ID_USUARIO,
            DIRECCION = P_DIRECCION
        WHERE ID_CLIENTE = P_ID_CLIENTE;

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ELIMINAR_CLIENTE(
        P_ID_CLIENTE IN NUMBER
    ) AS
    BEGIN
        UPDATE CLIENTES
        SET ID_ESTADO = CASE
                            WHEN ID_ESTADO = 1 THEN 2
                            WHEN ID_ESTADO = 2 THEN 1
                            ELSE ID_ESTADO
                        END
        WHERE ID_CLIENTE = P_ID_CLIENTE;

        COMMIT;
    END;

    PROCEDURE SP_OBTENER_CLIENTES_CS(
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT C.ID_CLIENTE, U.ID_USUARIO, U.NOMBRE, U.APELLIDO, U.TELEFONO, U.CORREO,
               E.ID_ESTADO, E.NOMBRE AS ESTADO, C.DIRECCION
        FROM CLIENTES C
        JOIN USUARIOS U ON U.ID_USUARIO = C.ID_USUARIO
        JOIN ESTADO E ON C.ID_ESTADO = E.ID_ESTADO;
    END;

    PROCEDURE SP_OBTENER_CLIENTE_CS(
        P_ID_CLIENTE IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT C.ID_CLIENTE, U.ID_USUARIO, U.NOMBRE, U.APELLIDO, U.TELEFONO, U.CORREO,
               E.ID_ESTADO, E.NOMBRE AS ESTADO, C.DIRECCION
        FROM CLIENTES C
        JOIN USUARIOS U ON U.ID_USUARIO = C.ID_USUARIO
        JOIN ESTADO E ON C.ID_ESTADO = E.ID_ESTADO
        WHERE C.ID_CLIENTE = P_ID_CLIENTE;
    END;

END PKG_CLIENTES;
/

-- Paquete para EMPLEADOS

--Especificacion del paquete EMPLEADOS
CREATE OR REPLACE PACKAGE PKG_EMPLEADOS AS

    PROCEDURE SP_INSERTAR_EMPLEADOS(
        P_ID_USUARIO IN NUMBER,
        P_CARGO IN VARCHAR2
    );

    PROCEDURE SP_ACTUALIZAR_EMPLEADOS(
        P_ID_EMPLEADO IN NUMBER,
        P_ID_USUARIO IN NUMBER,
        P_CARGO IN VARCHAR2
    );

    PROCEDURE SP_ELIMINAR_EMPLEADOS(
        P_ID_EMPLEADO IN NUMBER
    );

    PROCEDURE SP_OBTENER_EMPLEADOS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    );

    PROCEDURE SP_OBTENER_EMPLEADO_CS(
        P_ID_EMPLEADO IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    );

END PKG_EMPLEADOS;
/
CREATE OR REPLACE PACKAGE BODY PKG_EMPLEADOS AS

    PROCEDURE SP_INSERTAR_EMPLEADOS(
        P_ID_USUARIO IN NUMBER,
        P_CARGO IN VARCHAR2
    ) AS 
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM EMPLEADOS
        WHERE ID_USUARIO = P_ID_USUARIO;

        IF V_COUNT > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Ya existe un empleado con el mismo id.');
        END IF;

        INSERT INTO EMPLEADOS (ID_USUARIO, CARGO)
        VALUES (P_ID_USUARIO, P_CARGO);

        COMMIT;

    EXCEPTION
        WHEN VALUE_ERROR THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error en los datos proporcionados. Verifique los tipos de datos.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20003, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ACTUALIZAR_EMPLEADOS(
        P_ID_EMPLEADO IN NUMBER,
        P_ID_USUARIO IN NUMBER,
        P_CARGO IN VARCHAR2
    ) AS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT
        FROM EMPLEADOS
        WHERE ID_EMPLEADO = P_ID_EMPLEADO;

        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'El empleado con el ID proporcionado no existe.');
        END IF;

        UPDATE EMPLEADOS
        SET ID_USUARIO = P_ID_USUARIO,
            CARGO = P_CARGO
        WHERE ID_EMPLEADO = P_ID_EMPLEADO;

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Se ha producido un error inesperado: ' || SQLERRM);
    END;

    PROCEDURE SP_ELIMINAR_EMPLEADOS(
        P_ID_EMPLEADO IN NUMBER
    ) AS
    BEGIN
        UPDATE EMPLEADOS
        SET ID_ESTADO = CASE
                            WHEN ID_ESTADO = 1 THEN 2
                            WHEN ID_ESTADO = 2 THEN 1
                            ELSE ID_ESTADO
                        END
        WHERE ID_EMPLEADO = P_ID_EMPLEADO;

        COMMIT;
    END;

    PROCEDURE SP_OBTENER_EMPLEADOS_CS(
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT C.ID_EMPLEADO, U.ID_USUARIO, U.NOMBRE, U.APELLIDO, U.TELEFONO, U.CORREO,
               E.ID_ESTADO, E.NOMBRE AS ESTADO, C.CARGO
        FROM EMPLEADOS C
        JOIN USUARIOS U ON U.ID_USUARIO = C.ID_USUARIO
        JOIN ESTADO E ON C.ID_ESTADO = E.ID_ESTADO;
    END;

    PROCEDURE SP_OBTENER_EMPLEADO_CS(
        P_ID_EMPLEADO IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN P_CURSOR FOR
        SELECT C.ID_EMPLEADO, U.ID_USUARIO, U.NOMBRE, U.APELLIDO, U.TELEFONO, U.CORREO,
               E.ID_ESTADO, E.NOMBRE AS ESTADO, C.CARGO
        FROM EMPLEADOS C
        JOIN USUARIOS U ON U.ID_USUARIO = C.ID_USUARIO
        JOIN ESTADO E ON C.ID_ESTADO = E.ID_ESTADO
        WHERE C.ID_EMPLEADO = P_ID_EMPLEADO;
    END;

END PKG_EMPLEADOS;
/

-- Procedimiento que recibe correo y contrase�a y devuelva los datos del usuario o NULL si no existe

CREATE OR REPLACE PROCEDURE sp_login(
    p_correo        IN  USUARIOS.CORREO%TYPE,
    p_contrasenna   IN  USUARIOS.CONTRASENNA%TYPE,
    p_id_usuario    OUT USUARIOS.ID_USUARIO%TYPE,
    p_nombre        OUT USUARIOS.NOMBRE%TYPE,
    p_apellido      OUT USUARIOS.APELLIDO%TYPE,
    p_id_estado     OUT USUARIOS.ID_ESTADO%TYPE,
    p_tipo_usuario  OUT VARCHAR2       -- 'EMPLEADO' | 'CLIENTE' | 'DESCONOCIDO'
) AS
BEGIN
    SELECT u.ID_USUARIO,
           u.NOMBRE,
           u.APELLIDO,
           u.ID_ESTADO
      INTO p_id_usuario,
           p_nombre,
           p_apellido,
           p_id_estado
      FROM USUARIOS u
     WHERE u.CORREO       = p_correo
       AND u.CONTRASENNA  = p_contrasenna;

    SELECT CASE
             WHEN EXISTS (
                    SELECT 1
                      FROM EMPLEADOS e
                     WHERE e.ID_USUARIO = p_id_usuario
                  )
               THEN 'EMPLEADO'
             WHEN EXISTS (
                    SELECT 1
                      FROM CLIENTES c
                     WHERE c.ID_USUARIO = p_id_usuario
                  )
               THEN 'CLIENTE'
             ELSE 'DESCONOCIDO'
           END
      INTO p_tipo_usuario
      FROM DUAL;

EXCEPTION
    WHEN NO_DATA_FOUND THEN        
        p_id_usuario   := NULL;
        p_nombre       := NULL;
        p_apellido     := NULL;
        p_id_estado    := NULL;
        p_tipo_usuario := NULL;
END sp_login;
/

-- Se agregan datos al campo contrase�a ya que estaban en NULL
UPDATE USUARIOS
   SET CONTRASENNA = '1234'
 WHERE CORREO = 'carlosp@example.com';

UPDATE USUARIOS
   SET CONTRASENNA = '2345'
 WHERE CORREO = 'anam@example.com';

UPDATE USUARIOS
   SET CONTRASENNA = '3456'
 WHERE CORREO = 'carlosl@example.com';

UPDATE USUARIOS
   SET CONTRASENNA = '4567'
 WHERE CORREO = 'mariamar@example.com';

UPDATE USUARIOS
   SET CONTRASENNA = '5678'
 WHERE CORREO = 'luissolano@example.com';

COMMIT;

-- Se crea trigger que actualiza la cantidad de productos luego de realizar una venta
-- ademas valida que no se sobrepase el stock disponible
CREATE OR REPLACE TRIGGER trg_detalleventa_after_insert
AFTER INSERT ON DETALLE_VENTA
FOR EACH ROW
BEGIN
  UPDATE PRODUCTOS
     SET EXISTENCIAS = EXISTENCIAS - :NEW.CANTIDAD
   WHERE ID_PRODUCTO = :NEW.ID_PRODUCTO;

  DECLARE
    v_stock NUMBER;
  BEGIN
    SELECT EXISTENCIAS
      INTO v_stock
      FROM PRODUCTOS
     WHERE ID_PRODUCTO = :NEW.ID_PRODUCTO;

    IF v_stock < 0 THEN
      RAISE_APPLICATION_ERROR(
        -20001,
        'Stock insuficiente para el producto ID=' || :NEW.ID_PRODUCTO
      );
    END IF;
  END;
END trg_detalleventa_after_insert;


-- PAQUETE DE FUNCIONES
CREATE OR REPLACE PACKAGE pkg_funciones AS
    FUNCTION fn_total_clientes RETURN NUMBER;
    FUNCTION fn_total_empleados RETURN NUMBER;
    FUNCTION fn_total_proveedores RETURN NUMBER;
    FUNCTION fn_total_ventas RETURN NUMBER;
    FUNCTION fn_total_monto_ventas RETURN NUMBER;
    FUNCTION fn_producto_mas_vendido RETURN VARCHAR2;
    FUNCTION fn_producto_mas_caro RETURN VARCHAR2;
    FUNCTION fn_total_productos RETURN NUMBER;
    FUNCTION fn_total_especies RETURN NUMBER;
    FUNCTION fn_maximo_pago_cliente RETURN NUMBER;
    FUNCTION fn_total_categorias RETURN NUMBER;
    FUNCTION fn_especie_mas_vendida RETURN VARCHAR2;
    FUNCTION fn_cliente_mas_frecuente RETURN VARCHAR2;
    FUNCTION fn_empleado_top_ventas RETURN VARCHAR2;
    FUNCTION fn_categoria_mas_vendida RETURN VARCHAR2;
END pkg_funciones;
/


CREATE OR REPLACE PACKAGE BODY pkg_funciones AS

    FUNCTION fn_total_clientes RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_total FROM CLIENTES WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_total_empleados RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_total FROM EMPLEADOS WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_total_proveedores RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_total FROM PROVEEDORES WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_total_ventas RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_total FROM VENTAS WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_total_monto_ventas RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT NVL(SUM(TOTAL), 0) INTO v_total FROM VENTAS WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_producto_mas_vendido RETURN VARCHAR2 IS
        v_nombre PRODUCTOS.NOMBRE%TYPE;
    BEGIN
        SELECT P.NOMBRE
        INTO v_nombre
        FROM PRODUCTOS P
        JOIN DETALLE_VENTA D ON P.ID_PRODUCTO = D.ID_PRODUCTO
        GROUP BY P.NOMBRE
        ORDER BY SUM(D.CANTIDAD) DESC
        FETCH FIRST 1 ROWS ONLY;

        RETURN v_nombre;
    END;

    FUNCTION fn_producto_mas_caro RETURN VARCHAR2 IS
        v_nombre PRODUCTOS.NOMBRE%TYPE;
    BEGIN
        SELECT NOMBRE
        INTO v_nombre
        FROM PRODUCTOS
        WHERE PRECIO = (SELECT MAX(PRECIO) FROM PRODUCTOS);

        RETURN v_nombre;
    END;

    FUNCTION fn_total_productos RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_total FROM PRODUCTOS WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_total_especies RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_total FROM ESPECIE WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_maximo_pago_cliente RETURN NUMBER IS
        v_max NUMBER;
    BEGIN
        SELECT NVL(MAX(TOTAL), 0) INTO v_max FROM VENTAS WHERE ID_ESTADO = 1;
        RETURN v_max;
    END;

    FUNCTION fn_total_categorias RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_total FROM CATEGORIAS WHERE ID_ESTADO = 1;
        RETURN v_total;
    END;

    FUNCTION fn_especie_mas_vendida RETURN VARCHAR2 IS
    v_nombre VARCHAR2(255);
    BEGIN
    SELECT E.NOMBRE
    INTO v_nombre
    FROM DETALLE_VENTA D
    JOIN PRODUCTOS P ON D.ID_PRODUCTO = P.ID_PRODUCTO
    JOIN ESPECIE E ON P.ID_ESPECIE = E.ID_ESPECIE
    GROUP BY E.NOMBRE
    ORDER BY SUM(D.CANTIDAD) DESC
    FETCH FIRST 1 ROWS ONLY;

    RETURN v_nombre;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'Sin datos';
        END;

    FUNCTION fn_cliente_mas_frecuente RETURN VARCHAR2 IS
        v_nombre VARCHAR2(255);
    BEGIN
        SELECT U.NOMBRE || ' ' || U.APELLIDO
        INTO v_nombre
        FROM CLIENTES C
        JOIN USUARIOS U ON C.ID_USUARIO = U.ID_USUARIO
        JOIN VENTAS V ON V.ID_CLIENTE = C.ID_CLIENTE
        GROUP BY U.NOMBRE, U.APELLIDO
        ORDER BY COUNT(V.ID_VENTA) DESC
        FETCH FIRST 1 ROWS ONLY;

        RETURN v_nombre;
    END;

    FUNCTION fn_empleado_top_ventas RETURN VARCHAR2 IS
        v_nombre VARCHAR2(255);
    BEGIN
        SELECT U.NOMBRE || ' ' || U.APELLIDO
        INTO v_nombre
        FROM EMPLEADOS E
        JOIN USUARIOS U ON E.ID_USUARIO = U.ID_USUARIO
        JOIN VENTAS V ON V.ID_CLIENTE = E.ID_EMPLEADO
        GROUP BY U.NOMBRE, U.APELLIDO
        ORDER BY COUNT(V.ID_VENTA) DESC
        FETCH FIRST 1 ROWS ONLY;

        RETURN v_nombre;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'Sin datos';
    END;

    FUNCTION fn_categoria_mas_vendida RETURN VARCHAR2 IS
        v_nombre VARCHAR2(255);
    BEGIN
        SELECT C.NOMBRE
        INTO v_nombre
        FROM DETALLE_VENTA D
        JOIN PRODUCTOS P ON D.ID_PRODUCTO = P.ID_PRODUCTO
        JOIN CATEGORIAS C ON P.ID_CATEGORIA = C.ID_CATEGORIA
        GROUP BY C.NOMBRE
        ORDER BY SUM(D.CANTIDAD) DESC
        FETCH FIRST 1 ROWS ONLY;

        RETURN v_nombre;
    END;

END pkg_funciones;
/
-- PAQUETE DE REPORTES
CREATE OR REPLACE PACKAGE PK_REPORTES AS
  PROCEDURE MOSTRAR_CLIENTES_PREMIUM(p_cursor OUT SYS_REFCURSOR);
  PROCEDURE MOSTRAR_STOCK_PRODUCTOS(p_cursor OUT SYS_REFCURSOR);
END PK_REPORTES;
/
CREATE OR REPLACE PACKAGE BODY PK_REPORTES AS

  PROCEDURE MOSTRAR_CLIENTES_PREMIUM(p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT NOMBRE || ' ' || APELLIDO AS NOMBRE_COMPLETO, TOTAL_GASTADO 
      FROM V_CLIENTES_PREMIUM;
  EXCEPTION
    WHEN OTHERS THEN
      NULL; 
  END MOSTRAR_CLIENTES_PREMIUM;

  PROCEDURE MOSTRAR_STOCK_PRODUCTOS(p_cursor OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_cursor FOR
      SELECT PRODUCTO, PROVEEDOR, EXISTENCIAS
      FROM V_STOCK_PRODUCTOS;
  EXCEPTION
    WHEN OTHERS THEN
      NULL;
  END MOSTRAR_STOCK_PRODUCTOS;

END PK_REPORTES;
/
-- VISTAS

--1. Vista de productos con sus categor�as y especies

CREATE OR REPLACE VIEW V_PRODUCTOS_CATEGORIA_ESPECIE AS
SELECT p.ID_PRODUCTO, p.NOMBRE, p.DESCRIPCION, p.PRECIO, c.NOMBRE AS CATEGORIA, e.NOMBRE AS ESPECIE
FROM PRODUCTOS p
JOIN CATEGORIAS c ON p.ID_CATEGORIA = c.ID_CATEGORIA
JOIN ESPECIE e ON p.ID_ESPECIE = e.ID_ESPECIE;

--2. Vista de ventas con detalles de cliente

CREATE OR REPLACE VIEW V_VENTAS_CLIENTE AS
SELECT v.ID_VENTA, v.FECHA_VENTA, v.TOTAL, c.ID_CLIENTE, u.NOMBRE, u.APELLIDO
FROM VENTAS v
JOIN CLIENTES c ON v.ID_CLIENTE = c.ID_CLIENTE
JOIN USUARIOS u ON c.ID_USUARIO = u.ID_USUARIO;

--3. Vista de empleados con sus cargos y datos personales

CREATE OR REPLACE VIEW V_EMPLEADOS AS
SELECT e.ID_EMPLEADO, u.NOMBRE, u.APELLIDO, e.CARGO, u.TELEFONO, u.CORREO
FROM EMPLEADOS e
JOIN USUARIOS u ON e.ID_USUARIO = u.ID_USUARIO;

--4. Vista de stock de productos por proveedor

CREATE OR REPLACE VIEW V_STOCK_PRODUCTOS AS
SELECT p.NOMBRE AS PRODUCTO, pr.NOMBRE AS PROVEEDOR, p.EXISTENCIAS
FROM PRODUCTOS p
JOIN PROVEEDORES pr ON p.ID_PROVEEDOR = pr.ID_PROVEEDOR;

--5. Vista de clientes y sus compras totales

CREATE OR REPLACE VIEW V_CLIENTES_COMPRAS AS
SELECT c.ID_CLIENTE, u.NOMBRE, u.APELLIDO, COUNT(v.ID_VENTA) AS NUM_COMPRAS, SUM(v.TOTAL) AS TOTAL_GASTADO
FROM CLIENTES c
JOIN USUARIOS u ON c.ID_USUARIO = u.ID_USUARIO
JOIN VENTAS v ON c.ID_CLIENTE = v.ID_CLIENTE
GROUP BY c.ID_CLIENTE, u.NOMBRE, u.APELLIDO;

--6. Vista de los productos m�s vendidos

CREATE OR REPLACE VIEW V_PRODUCTOS_MAS_VENDIDOS AS
SELECT p.NOMBRE, SUM(dv.CANTIDAD) AS TOTAL_VENDIDO
FROM DETALLE_VENTA dv
JOIN PRODUCTOS p ON dv.ID_PRODUCTO = p.ID_PRODUCTO
GROUP BY p.NOMBRE
ORDER BY TOTAL_VENDIDO DESC;

--7. Vista de empleados que tambi�n son clientes

CREATE OR REPLACE VIEW V_EMPLEADOS_CLIENTES AS
SELECT e.ID_EMPLEADO, u.NOMBRE, u.APELLIDO, e.CARGO
FROM EMPLEADOS e
JOIN CLIENTES c ON e.ID_USUARIO = c.ID_USUARIO
JOIN USUARIOS u ON e.ID_USUARIO = u.ID_USUARIO;

--8. Vista de ventas por mes

CREATE OR REPLACE VIEW V_VENTAS_MES AS
SELECT TO_CHAR(FECHA_VENTA, 'YYYY-MM') AS MES, COUNT(*) AS NUM_VENTAS, SUM(TOTAL) AS TOTAL_VENTAS
FROM VENTAS
GROUP BY TO_CHAR(FECHA_VENTA, 'YYYY-MM');

--9. Vista de los proveedores con la cantidad de productos que suministran

CREATE OR REPLACE VIEW V_PROVEEDORES_PRODUCTOS AS
SELECT pr.NOMBRE, COUNT(p.ID_PRODUCTO) AS TOTAL_PRODUCTOS
FROM PROVEEDORES pr
JOIN PRODUCTOS p ON pr.ID_PROVEEDOR = p.ID_PROVEEDOR
GROUP BY pr.NOMBRE;

--10. Vista de clientes que han gastado m�s de $1000

CREATE OR REPLACE VIEW V_CLIENTES_PREMIUM AS
SELECT c.ID_CLIENTE, u.NOMBRE, u.APELLIDO, SUM(v.TOTAL) AS TOTAL_GASTADO
FROM CLIENTES c
JOIN USUARIOS u ON c.ID_USUARIO = u.ID_USUARIO
JOIN VENTAS v ON c.ID_CLIENTE = v.ID_CLIENTE
GROUP BY c.ID_CLIENTE, u.NOMBRE, u.APELLIDO
HAVING SUM(v.TOTAL) > 10000;






